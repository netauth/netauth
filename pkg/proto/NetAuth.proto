// This is the master proto for NetAuth.  It contains the RPC
// definitions needed to auth a user as well as to change the state of
// a user's account.

syntax = "proto2";

// Capabilities permit the holder to perform special actions within
// NetAuth.  This allows the holder to do things related to management
// of the server without needing to use the GLOBAL_ROOT bootstrap
// user.
enum Capability {
  GLOBAL_ROOT = 0;
  CREATE_ENTITY = 1;
  DESTORY_ENTITY = 2;
  MODIFY_ENTITY_META = 3;
  CHANGE_ENTITY_SECRET = 4;
  CREATE_GROUP = 5;
  DESTROY_GROUP = 6;
  MODIFY_GROUP_META = 7;
  MODIFY_GROUP_MEMBERS = 8;
}

service NetAuth {
  // It is desireable to ping the server for status and health
  rpc Ping(PingRequest) returns (PingResponse) {}

  //////////////////////////////////////////
  // Authentication and secret management //
  //////////////////////////////////////////

  // AuthEntity and GetToken both verify that an entity is who they
  // claim to be (or at least that they posses the identifying
  // information) with the only difference being that GetToken will
  // unsurprisingly return a token on success.
  rpc AuthEntity(NetAuthRequest) returns (SimpleResult) {}
  rpc GetToken(NetAuthRequest) returns (TokenResult) {}
  rpc ValidateToken(NetAuthRequest) returns (SimpleResult) {}

  // ChangeSecret is unusual in that it uses the token if vouching for
  // *another* entitie's secret being changed, but if the change is
  // for the requesting entity, the original secret must be provided.
  rpc ChangeSecret(ModEntityRequest) returns (SimpleResult) {}


  ///////////////////////
  // Entity Management //
  ///////////////////////

  // Add and remove Entities
  rpc NewEntity(ModEntityRequest) returns (SimpleResult) {}
  rpc RemoveEntity(ModEntityRequest) returns (SimpleResult) {}

  // Get and set meta information about entities
  rpc EntityInfo(NetAuthRequest) returns (Entity) {}
  rpc ModifyEntityMeta(ModEntityRequest) returns (SimpleResult) {}


  //////////////////////
  // Group Management //
  //////////////////////

  // Add, Remove, and Modify groups
  rpc NewGroup(ModGroupRequest) returns (SimpleResult) {}
  rpc DeleteGroup(ModGroupRequest) returns (SimpleResult) {}
  rpc ModifyGroupMeta(ModGroupRequest) returns (SimpleResult) {}

  // List groups
  rpc ListGroups(GroupListRequest) returns (GroupList) {}

  // // Modify direct group membership
  // rpc AddEntityToGroup(ModGroupDirectMembershipRequest) returns (SimpleResult) {}
  // rpc RemoveEntityFromGroup(ModGroupDirectMembershipRequest) returns (SimpleResult) {}
  // rpc ListGroupMembers(GroupMemberRequest) returns (EntityList) {}
}

// The ClientInfo message contains information about the client
// originating the request.  This information must not be used for
// security functions of any kind, as it is directly editable by the
// client.
message ClientInfo {
  // The ID is to be used to define the originating client, this
  // should in general be set to the client's hostname, or otherwise
  // some persistent system identifier.
  optional string ID = 1;

  // The Service is an identifier that defined what is asking the
  // system for information.  This should usually be set to the
  // application name, or 'SYSTEM' if the request is on behalf of the
  // system itself.
  optional string Service = 2;
}

// An AuthRequest includes an Entity and some information to identify
// the system that is making the request.
message NetAuthRequest {
  // The Entity is obviously the most important part of the
  // AuthRequest which is the thing we want to authenticate.
  required Entity Entity = 1;

  optional string AuthToken = 2;

  // Client information for logging
  optional ClientInfo Info = 3;
}

// A ModEntityRequest takes an entity to authorize and an entity to
// act upon.  These may be the same entity for changes being applied
// by an entity to itself.
message ModEntityRequest {
  // The request must always have an entity, the second entity may not
  // be set in which case the first entity will be acted upon.
  required Entity Entity = 1;

  // This is the entity to act on, it may be set or it may not be.
  optional Entity ModEntity = 2;

  // Client information for logging
  optional ClientInfo Info = 3;

  // The authentication token is used to authorize changes made to the
  // state of things in the NetAuth database.
  required string AuthToken = 4;
}

message ModGroupDirectMembershipRequest {
  // The change is authorized by an entity, not necessarily the one that's being changed.
  required Entity entity = 1;
  optional string modEntity = 2;

  // The group that is being added or removed is taken as a group name
  required string GroupName = 3;

  // Client information for logging
  optional ClientInfo Info = 4;

  // The authentication token is used to authorize changes made to the
  // state of things in the NetAuth database.
  required string AuthToken = 5;
}

// An entity may be a person or a machine actor that wishes to act as
// some identity.  To do so they will need to transmit an ID and a
// secret which will be used to verify that they are who they say they
// are.
message Entity {
  // The entity may be identified by a string.  This is most common
  // for the initial authentication case where a people-entity has
  // typed a name in and now wishes to be authenticated.
  optional string ID = 1;

  // An entity might also be identified by a unique ID number.  This
  // case is most common when some program wishes to get information
  // about an entity.
  optional int32 uidNumber = 2;

  // The entity may have a secret which they will use to authenticate
  // themselves.
  optional string secret = 3;

  // For requests that update the meta information this must be
  // attatched to the entity itself.  This also allows the in-memory
  // format to be defined by this proto.
  optional EntityMeta meta = 4;
}

// A SimpleResult can be returned from most services and explains
// whether or not the service completed successfully or not, and an
// optional message that may explain in more detail.
message SimpleResult {
  // Required is forever, but a SimpleResult without a success state
  // doesn't mean much.  This field must be present in all replies.
  required bool success = 1 [default = false];

  // In the failure case a message may be provided detailing the
  // failure.  This message must not contain secure information and
  // there must be an expectation that anything placed in this field
  // will be shown directly to a person or written to a log.
  optional string msg = 2;
}

// A token reply will include the status of the authentication
// request, and if successful, an authentication token that can be
// used for future requests.
message TokenResult {
  // Success will provide a high level status of if the reply
  // succeeded.
  required bool success = 1 [default = false];

  // Msg contains information about a failure if applicable.
  optional string Msg = 2;

  // Token contains the token if the request was successful or is
  // empty otherwise.
  optional string Token = 3;
}

// While machine entities may belong to only one group, people
// entities often belong to many groups at once.  This message
// structures the reply for the additional groups.
message Group {
  // A group name must satisfy the requirements of the UNIX group
  // naming conventions.  This should be one word, lower case, with no
  // spaces and cannot begin with a number.
  optional string Name = 1;

  // Since the name has strict naming requirements, its nice to have a
  // displayName for the group which has a more friendly display.
  // Instead of trying to reason out what naacct means, its much nicer
  // to just know that its "Accounting team - North America"
  optional string DisplayName = 2;

  // On *nix systems the group should also have a number.  This number
  // should be the same across all systems since it may be used for
  // internal matching of users.
  optional int32 gidNumber = 3;

  // Groups may have capabilities that are conferred to members of the
  // group on a membership basis.  This is the preferred way of
  // granting capabilities to an entity since it means that when an
  // entity is removed from the group they lose the capabilities that
  // were granted from it.
  repeated Capability Capabilities = 4;
}

message ModGroupRequest {
  // The AuthToken for authorization of changes to the database.
  required string AuthToken = 1;

  // The group that's being modified.
  required Group Group = 2;

  // Client information for logging
  optional ClientInfo Info = 3;
}

message GroupMemberRequest {
  // The group for which info is being requested.
  optional Group Group = 1;

  // Client information for logging
  optional ClientInfo Info = 2;
}

message GroupListRequest{
  optional ClientInfo Info = 1;
}

message GroupList {
  repeated Group Groups = 1;
}

message EntityMeta {
  // The primary group ID for the entity.  On most UNIX systems this
  // will map to a group with the same string representation as the
  // Entity, but it is not uncommon for people-entities in a network
  // environment to not have a personal primary group and instead
  // belong to an organization wide primary group.
  optional Group pgid = 1;

  // This is an arbitrary field used to store things like the user's
  // real name.  It is here for consistency, but the name displayed by
  // the user should really be stored in displayName, with the actual
  // name stored in legalName (this facilitates a user to have an
  // arbitrary name displayed if this is permitted by local policy).
  optional string GECOS = 2;

  // This stores the legal name (if used) that owns this security
  // entity.  This primarily here for places where knowing the single
  // owning entity is a requirement for compliance reasons.
  optional string legalName = 3;

  // This field is for the display value of the legalName.  This lets
  // the displayed value fluctuate with no connection to the actual
  // identity of the owning entity.
  optional string displayName = 4;

  // Given that the entity identity and auth are provided by the
  // network, its not unlikely that the home directory for the entity
  // is as well.  This string contains the fully qualified path to the
  // home directory.
  optional string homedir = 5;

  // This string is the canonical 'user command interpreter' specified
  // in the passwd file.  This value provided by this field must be
  // safe to use on all target systems as setting this to something
  // that doesn't exist on the targets will cause the login program to
  // abort when setting up the environment.
  optional string shell = 6;

  // This is for the graphical shell, primarily for when the entity is
  // a person (though machine entities might also need to have a
  // graphical shell set).  This provides a handy place to store it,
  // but unfortunately a seperate mechanism is needed to get this into
  // the systems that actually setup the graphical environment.
  optional string graphicalShell = 7;

  // Person entities may have a physical badge which gets them access
  // to things, and machine entities may have an asset tag which is
  // nice to keep track of.  This is a string rather than a number
  // because the badge "number" might actually be a UUID or something
  // that is not otherwise a pure number.
  optional string badgeNumber = 8;

  // Entities may be direct members of groups
  repeated string groups = 9;

  // Entities may have capabilities that provide special actions to
  // the holder within NetAuth.
  repeated Capability capabilities = 10;
}

// GroupMemberList is returned when a query generates a list of
// entities.
message EntityList {
  repeated Entity members = 1;
}

// The PingRequest is used to ask the server to return its health
// status to the requestor.
message PingRequest {
  // Client information for logging
  optional ClientInfo Info = 1;
}

// The PingReply is used to tell the client if this server is healthy
// and ready to serve.
message PingResponse {
  // The server will reply healthy=True if it is ready to serve.
  optional bool healthy = 1;

  // Optionally the server may have a message if it is not healthy.
  optional string msg = 2;
}
